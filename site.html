<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Gravity Simulation Test</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Simple Body class
class Body {
  constructor(x,y,vx,vy,radius,color){
    this.pos=[x,y,0]; this.vel=[vx,vy,0]; this.radius=radius; this.color=color;
  }
  update(dt){ this.pos[0]+=this.vel[0]*dt; this.pos[1]+=this.vel[1]*dt; }
}

// Simulation setup - MUCH BIGGER objects
let bodies = [
  new Body(0, 0, 0, 0, 15, 0xffff00),      // Sun - big yellow sphere
  new Body(50, 0, 0, 1, 8, 0x00bfff)       // Earth - smaller blue sphere
];

// THREE.JS setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000011); // Very dark blue so we can see it's rendering

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 120; // Far enough to see the orbit

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Add some ambient light to make spheres visible
const light = new THREE.AmbientLight(0xffffff, 1);
scene.add(light);

let meshes = [];
bodies.forEach(b=>{
  let geo = new THREE.SphereGeometry(b.radius, 32, 32);
  let mat = new THREE.MeshBasicMaterial({color: b.color});
  let mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(...b.pos);
  scene.add(mesh);
  meshes.push(mesh);
  console.log(`Added sphere at ${b.pos}, radius ${b.radius}, color ${b.color}`);
});

console.log('Scene has', scene.children.length, 'objects');
console.log('Camera at', camera.position);

// Animation loop
function animate(){
  requestAnimationFrame(animate);
  bodies.forEach((b,i)=>{
    b.update(0.3);
    meshes[i].position.set(...b.pos);
  });
  renderer.render(scene, camera);
}
animate();

// Window resize handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>