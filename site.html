<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Gravity Simulation</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: monospace;
    font-size: 14px;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="info">Click and drag to rotate | Scroll to zoom</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Body class with 3D support
class Body {
  constructor(x,y,z,vx,vy,vz,radius,color){
    this.pos=[x,y,z]; 
    this.vel=[vx,vy,vz]; 
    this.radius=radius; 
    this.color=color;
  }
  update(dt){ 
    this.pos[0]+=this.vel[0]*dt; 
    this.pos[1]+=this.vel[1]*dt; 
    this.pos[2]+=this.vel[2]*dt;
  }
}

// 3D Simulation setup
let bodies = [
  new Body(0, 0, 0, 0, 0, 0, 15, 0xffff00),           // Sun
  new Body(50, 0, 0, 0, 1, 0, 6, 0x00bfff),           // Earth (XY plane)
  new Body(0, 40, 20, 0.8, 0, -0.5, 5, 0xff6b6b),     // Mars (YZ plane)
  new Body(-35, -35, 0, 0.7, 0.7, 0, 4, 0x9d4edd)     // Venus (diagonal XY)
];

// THREE.JS setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(100, 80, 100);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Add lighting for 3D effect
const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(0xffffff, 1, 300);
pointLight.position.set(0, 0, 0);
scene.add(pointLight);

// Create sphere meshes
let meshes = [];
bodies.forEach(b=>{
  let geo = new THREE.SphereGeometry(b.radius, 32, 32);
  let mat = new THREE.MeshPhongMaterial({
    color: b.color,
    emissive: b.radius > 10 ? b.color : 0x000000,
    emissiveIntensity: b.radius > 10 ? 0.5 : 0,
    shininess: 30
  });
  let mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(...b.pos);
  scene.add(mesh);
  meshes.push(mesh);
});

// Add orbit trails
let trailPoints = bodies.map(() => []);
let trailLines = [];
bodies.forEach((b, i) => {
  const geometry = new THREE.BufferGeometry();
  const material = new THREE.LineBasicMaterial({ 
    color: b.color, 
    opacity: 0.3, 
    transparent: true 
  });
  const line = new THREE.Line(geometry, material);
  scene.add(line);
  trailLines.push(line);
});

// Mouse controls for camera rotation
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let cameraRotation = { theta: Math.PI / 4, phi: Math.PI / 6 };
let cameraDistance = 150;

renderer.domElement.addEventListener('mousedown', (e) => {
  isDragging = true;
  previousMousePosition = { x: e.clientX, y: e.clientY };
});

renderer.domElement.addEventListener('mousemove', (e) => {
  if (isDragging) {
    const deltaX = e.clientX - previousMousePosition.x;
    const deltaY = e.clientY - previousMousePosition.y;
    
    cameraRotation.theta -= deltaX * 0.01;
    cameraRotation.phi -= deltaY * 0.01;
    cameraRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraRotation.phi));
    
    previousMousePosition = { x: e.clientX, y: e.clientY };
  }
});

renderer.domElement.addEventListener('mouseup', () => {
  isDragging = false;
});

renderer.domElement.addEventListener('wheel', (e) => {
  e.preventDefault();
  cameraDistance += e.deltaY * 0.1;
  cameraDistance = Math.max(50, Math.min(300, cameraDistance));
});

// Animation loop
function animate(){
  requestAnimationFrame(animate);
  
  // Update bodies
  bodies.forEach((b,i)=>{
    b.update(0.3);
    meshes[i].position.set(...b.pos);
    
    // Update trails
    trailPoints[i].push(new THREE.Vector3(...b.pos));
    if (trailPoints[i].length > 200) trailPoints[i].shift();
    
    const positions = new Float32Array(trailPoints[i].length * 3);
    trailPoints[i].forEach((p, idx) => {
      positions[idx * 3] = p.x;
      positions[idx * 3 + 1] = p.y;
      positions[idx * 3 + 2] = p.z;
    });
    trailLines[i].geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  });
  
  // Update camera position
  camera.position.x = cameraDistance * Math.sin(cameraRotation.phi) * Math.cos(cameraRotation.theta);
  camera.position.y = cameraDistance * Math.cos(cameraRotation.phi);
  camera.position.z = cameraDistance * Math.sin(cameraRotation.phi) * Math.sin(cameraRotation.theta);
  camera.lookAt(0, 0, 0);
  
  renderer.render(scene, camera);
}
animate();

// Window resize handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>